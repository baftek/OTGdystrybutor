/*   Plik ds18b20.c   (minimum kodu do odczytu temperatury z ds18b20)   xyz.isgreat.org*/#include <avr/io.h>#include <util/delay.h>#include "ds18b20.h"#include <avr/interrupt.h>#define ONEWIREPOWER_ON PORTB |= 0x04#define ONEWIREPOWER_OFF PORTB &= ~(0x04)/**********************************************************///unsigned char ds18b20_ConvertT(unsigned char ROM_code[]){  if (!OneWireReset()) return 0;  if(ROM_code[0] == 0x00)  OneWireWriteByte(0xcc); // SKIP ROM  else  ds18b20_Match_ROM(ROM_code); // MATCH ROM (choose one unit to answer)    OneWireWriteByte(0x44); // CONVERT T  _delay_ms(750);  return 1;}/***********************************************************///int ds18b20_Read(unsigned char scratchpad[], unsigned char ROM_code[]){  unsigned char i;      if (!OneWireReset()) return 0;  if(ROM_code[0] == 0x00)  OneWireWriteByte(0xcc); // SKIP ROM  else  ds18b20_Match_ROM(ROM_code); // MATCH ROM (choose one unit to answer)    OneWireWriteByte(0xbe); // READ SCRATCHPAD  for(i=0; i<9; i++) scratchpad[i] = OneWireReadByte();    return 1;}/***********************************************************////*int ds18b20_Write(unsigned char data1, unsigned char data2, unsigned char data3, unsigned char ROM_code[]){  unsigned char i;      if (!OneWireReset()) return 0;  if(ROM_code[0] == 0x00)  OneWireWriteByte(0xcc); // SKIP ROM  else  ds18b20_Match_ROM(ROM_code); // MATCH ROM (choose one unit to answer)    OneWireWriteByte(0x4e); // WRITE SCRATCHPAD  OneWireWriteByte(data1);  OneWireWriteByte(data2);  OneWireWriteByte(data3);    return 1;}*//**********************************************************///int ds18b20_Read_ROM(unsigned char ROM_data[]){  unsigned char i;      if (!OneWireReset()) return 0;  OneWireWriteByte(0x33); // READ ROM  for(i=0; i<8; i++) ROM_data[i] = OneWireReadByte();   return 1;}/**********************************************************/int ds18b20_Match_ROM(unsigned char ROM_data[]){  unsigned char i;      OneWireWriteByte(0x55); // MATCH ROM  for(i=0; i<8; i++)   OneWireWriteByte(ROM_data[i]);   return 1;}/**********************************************************/void OneWireStrong(char s){  if (s)  {     SET_ONEWIRE_PORT;      SET_OUT_ONEWIRE_DDR;   }  else  {     SET_IN_ONEWIRE_DDR;   }}/**********************************************************/unsigned char OneWireReset(){		CLR_ONEWIRE_PORT; 		if (!(IS_SET_ONEWIRE_PIN)) 		return 0; 				SET_OUT_ONEWIRE_DDR; 		_delay_us(500);		SET_IN_ONEWIRE_DDR; 		_delay_us(70);		if(!(IS_SET_ONEWIRE_PIN))		{			_delay_us(500);			return(1);		}		_delay_us(500);		return(0);}/**********************************************************/void OneWireWriteByte(unsigned char byte){   unsigned char i;//cli();   CLR_ONEWIRE_PORT;    for (i=0; i<8; i++)   {     SET_OUT_ONEWIRE_DDR;      if (byte & 0x01)     {       _delay_us(7);       SET_IN_ONEWIRE_DDR;        _delay_us(70);     }     else     {        _delay_us(70);        SET_IN_ONEWIRE_DDR;         _delay_us(7);     }     byte >>= 1;   }//sei();}/***********************************************************/unsigned char OneWireReadByte(void){  unsigned char i, byte = 0;//cli();  SET_IN_ONEWIRE_DDR;     for (i=0; i<8; i++)  {     SET_OUT_ONEWIRE_DDR;      _delay_us(7);     SET_IN_ONEWIRE_DDR;      _delay_us(7);     byte >>= 1;          if(IS_SET_ONEWIRE_PIN) byte |= 0x80;     _delay_us(70);  }//sei();  return byte;}